/* automatically generated by rust-bindgen */

pub const FSE_VERSION_MAJOR: u32 = 0;
pub const FSE_VERSION_MINOR: u32 = 9;
pub const FSE_VERSION_RELEASE: u32 = 0;
pub const FSE_VERSION_NUMBER: u32 = 900;
pub type wchar_t = ::std::os::raw::c_ushort;
pub type max_align_t = f64;
extern "C" {
    pub fn FSE_versionNumber() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " FSE_compress() :"]
    #[doc = "Compress content of buffer \'src\', of size \'srcSize\', into destination buffer \'dst\'."]
    #[doc = "\'dst\' buffer must be already allocated. Compression runs faster is dstCapacity >= FSE_compressBound(srcSize)."]
    #[doc = "@return : size of compressed data (<= dstCapacity)."]
    #[doc = "Special values : if return == 0, srcData is not compressible => Nothing is stored within dst !!!"]
    #[doc = "if return == 1, srcData is a single byte symbol * srcSize times. Use RLE compression instead."]
    #[doc = "if FSE_isError(return), compression failed (more details using FSE_getErrorName())"]
    pub fn FSE_compress(
        dst: *mut ::std::os::raw::c_void,
        dstCapacity: usize,
        src: *const ::std::os::raw::c_void,
        srcSize: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " FSE_decompress():"]
    #[doc = "Decompress FSE data from buffer \'cSrc\', of size \'cSrcSize\',"]
    #[doc = "into already allocated destination buffer \'dst\', of size \'dstCapacity\'."]
    #[doc = "@return : size of regenerated data (<= maxDstSize),"]
    #[doc = "or an error code, which can be tested using FSE_isError() ."]
    #[doc = ""]
    #[doc = " Important ** : FSE_decompress() does not decompress non-compressible nor RLE data !!!"]
    #[doc = "Why ? : making this distinction requires a header."]
    #[doc = "Header management is intentionally delegated to the user layer, which can better manage special cases."]
    pub fn FSE_decompress(
        dst: *mut ::std::os::raw::c_void,
        dstCapacity: usize,
        cSrc: *const ::std::os::raw::c_void,
        cSrcSize: usize,
    ) -> usize;
}
extern "C" {
    pub fn FSE_compressBound(size: usize) -> usize;
}
extern "C" {
    pub fn FSE_isError(code: usize) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn FSE_getErrorName(code: usize) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " FSE_compress2() :"]
    #[doc = "Same as FSE_compress(), but allows the selection of \'maxSymbolValue\' and \'tableLog\'"]
    #[doc = "Both parameters can be defined as \'0\' to mean : use default value"]
    #[doc = "@return : size of compressed data"]
    #[doc = "Special values : if return == 0, srcData is not compressible => Nothing is stored within cSrc !!!"]
    #[doc = "if return == 1, srcData is a single byte symbol * srcSize times. Use RLE compression."]
    #[doc = "if FSE_isError(return), it\'s an error code."]
    pub fn FSE_compress2(
        dst: *mut ::std::os::raw::c_void,
        dstSize: usize,
        src: *const ::std::os::raw::c_void,
        srcSize: usize,
        maxSymbolValue: ::std::os::raw::c_uint,
        tableLog: ::std::os::raw::c_uint,
    ) -> usize;
}
extern "C" {
    #[doc = " FSE_optimalTableLog():"]
    #[doc = "dynamically downsize \'tableLog\' when conditions are met."]
    #[doc = "It saves CPU time, by using smaller tables, while preserving or even improving compression ratio."]
    #[doc = "@return : recommended tableLog (necessarily <= \'maxTableLog\')"]
    pub fn FSE_optimalTableLog(
        maxTableLog: ::std::os::raw::c_uint,
        srcSize: usize,
        maxSymbolValue: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " FSE_normalizeCount():"]
    #[doc = "normalize counts so that sum(count[]) == Power_of_2 (2^tableLog)"]
    #[doc = "\'normalizedCounter\' is a table of short, of minimum size (maxSymbolValue+1)."]
    #[doc = "@return : tableLog,"]
    #[doc = "or an errorCode, which can be tested using FSE_isError()"]
    pub fn FSE_normalizeCount(
        normalizedCounter: *mut ::std::os::raw::c_short,
        tableLog: ::std::os::raw::c_uint,
        count: *const ::std::os::raw::c_uint,
        srcSize: usize,
        maxSymbolValue: ::std::os::raw::c_uint,
    ) -> usize;
}
extern "C" {
    #[doc = " FSE_NCountWriteBound():"]
    #[doc = "Provides the maximum possible size of an FSE normalized table, given \'maxSymbolValue\' and \'tableLog\'."]
    #[doc = "Typically useful for allocation purpose."]
    pub fn FSE_NCountWriteBound(
        maxSymbolValue: ::std::os::raw::c_uint,
        tableLog: ::std::os::raw::c_uint,
    ) -> usize;
}
extern "C" {
    #[doc = " FSE_writeNCount():"]
    #[doc = "Compactly save \'normalizedCounter\' into \'buffer\'."]
    #[doc = "@return : size of the compressed table,"]
    #[doc = "or an errorCode, which can be tested using FSE_isError()."]
    pub fn FSE_writeNCount(
        buffer: *mut ::std::os::raw::c_void,
        bufferSize: usize,
        normalizedCounter: *const ::std::os::raw::c_short,
        maxSymbolValue: ::std::os::raw::c_uint,
        tableLog: ::std::os::raw::c_uint,
    ) -> usize;
}
#[doc = " Constructor and Destructor of FSE_CTable."]
#[doc = "Note that FSE_CTable size depends on \'tableLog\' and \'maxSymbolValue\'"]
pub type FSE_CTable = ::std::os::raw::c_uint;
extern "C" {
    pub fn FSE_createCTable(
        maxSymbolValue: ::std::os::raw::c_uint,
        tableLog: ::std::os::raw::c_uint,
    ) -> *mut FSE_CTable;
}
extern "C" {
    pub fn FSE_freeCTable(ct: *mut FSE_CTable);
}
extern "C" {
    #[doc = " FSE_buildCTable():"]
    #[doc = "Builds `ct`, which must be already allocated, using FSE_createCTable()."]
    #[doc = "@return : 0, or an errorCode, which can be tested using FSE_isError()"]
    pub fn FSE_buildCTable(
        ct: *mut FSE_CTable,
        normalizedCounter: *const ::std::os::raw::c_short,
        maxSymbolValue: ::std::os::raw::c_uint,
        tableLog: ::std::os::raw::c_uint,
    ) -> usize;
}
extern "C" {
    #[doc = " FSE_compress_usingCTable():"]
    #[doc = "Compress `src` using `ct` into `dst` which must be already allocated."]
    #[doc = "@return : size of compressed data (<= `dstCapacity`),"]
    #[doc = "or 0 if compressed data could not fit into `dst`,"]
    #[doc = "or an errorCode, which can be tested using FSE_isError()"]
    pub fn FSE_compress_usingCTable(
        dst: *mut ::std::os::raw::c_void,
        dstCapacity: usize,
        src: *const ::std::os::raw::c_void,
        srcSize: usize,
        ct: *const FSE_CTable,
    ) -> usize;
}
extern "C" {
    #[doc = " FSE_readNCount():"]
    #[doc = "Read compactly saved \'normalizedCounter\' from \'rBuffer\'."]
    #[doc = "@return : size read from \'rBuffer\',"]
    #[doc = "or an errorCode, which can be tested using FSE_isError()."]
    #[doc = "maxSymbolValuePtr[0] and tableLogPtr[0] will also be updated with their respective values"]
    pub fn FSE_readNCount(
        normalizedCounter: *mut ::std::os::raw::c_short,
        maxSymbolValuePtr: *mut ::std::os::raw::c_uint,
        tableLogPtr: *mut ::std::os::raw::c_uint,
        rBuffer: *const ::std::os::raw::c_void,
        rBuffSize: usize,
    ) -> usize;
}
#[doc = " Constructor and Destructor of FSE_DTable."]
#[doc = "Note that its size depends on \'tableLog\'"]
pub type FSE_DTable = ::std::os::raw::c_uint;
extern "C" {
    pub fn FSE_createDTable(tableLog: ::std::os::raw::c_uint) -> *mut FSE_DTable;
}
extern "C" {
    pub fn FSE_freeDTable(dt: *mut FSE_DTable);
}
extern "C" {
    #[doc = " FSE_buildDTable():"]
    #[doc = "Builds \'dt\', which must be already allocated, using FSE_createDTable()."]
    #[doc = "return : 0, or an errorCode, which can be tested using FSE_isError()"]
    pub fn FSE_buildDTable(
        dt: *mut FSE_DTable,
        normalizedCounter: *const ::std::os::raw::c_short,
        maxSymbolValue: ::std::os::raw::c_uint,
        tableLog: ::std::os::raw::c_uint,
    ) -> usize;
}
extern "C" {
    #[doc = " FSE_decompress_usingDTable():"]
    #[doc = "Decompress compressed source `cSrc` of size `cSrcSize` using `dt`"]
    #[doc = "into `dst` which must be already allocated."]
    #[doc = "@return : size of regenerated data (necessarily <= `dstCapacity`),"]
    #[doc = "or an errorCode, which can be tested using FSE_isError()"]
    pub fn FSE_decompress_usingDTable(
        dst: *mut ::std::os::raw::c_void,
        dstCapacity: usize,
        cSrc: *const ::std::os::raw::c_void,
        cSrcSize: usize,
        dt: *const FSE_DTable,
    ) -> usize;
}
